using Emgu.CV;
using Emgu.CV.CvEnum;
using Emgu.CV.Structure;
using SolVision;
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Drawing;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Text.RegularExpressions;
using System.Threading.Tasks;
using System.Windows.Forms;
using System.Windows.Forms.Integration;

namespace DemoApp
{
    public partial class DemoApp : Form
    {
        private enum LogStatus
        {
            Info,
            Success,
            Warning,
            Error,
            Progress
        }

        private SolVision.TaskProcess SolDL;
        private DetectImg currentImage;
        private List<string> classNameList;
        private string loadedProjectPath = string.Empty;
        private RuleGroupNode logicRoot;
        private bool suppressLogicEvents;
        private readonly Color statusPassBackground = Color.FromArgb(232, 245, 233);
        private readonly Color statusPassForeground = Color.FromArgb(27, 94, 32);
        private readonly Color statusFailBackground = Color.FromArgb(255, 235, 238);
        private readonly Color statusFailForeground = Color.FromArgb(178, 34, 34);
        private readonly Color statusNeutralBackground = Color.FromArgb(245, 247, 250);
        private readonly Color statusNeutralForeground = Color.FromArgb(94, 102, 112);
        private TabControl leftTabs;
        private TabPage tabWorkflow;
        private TabPage tabLogicBuilder;
        private TableLayoutPanel workflowLayout;
        private Label LBL_WorkflowStatus;
        private TableLayoutPanel logicRootLayout;
        private Panel logicHeaderPanel;
        private Label labelLogicHeader;
        private Button BT_LogicHelp;
        private ToolTip toolTip;
        private Panel loadingIndicatorPanel;
        private ProgressBar loadingSpinner;
        private int loadingRequestCount;
        private GroupBox groupLogic;
        private TableLayoutPanel tableLayoutLogic;
        private TreeView TV_Logic;
        private Panel panelLogicEditor;
        private TableLayoutPanel tableLayoutLogicEditor;
        private Label labelLogicGroup;
        private ComboBox CB_GroupOperator;
        private Label labelLogicField;
        private ComboBox CB_Field;
        private Label labelLogicOperator;
        private ComboBox CB_Operator;
        private Label labelLogicValue;
        private ComboBox CB_Value;
        private TableLayoutPanel tableLayoutLogicButtons;
        private Button BT_AddRule;
        private Button BT_AddGroup;
        private Button BT_RemoveNode;
        private Label LBL_ResultStatus;

        public DemoApp()
        {
            InitializeComponent();
            BuildLogicBuilderUI();
            InitializeLoadingIndicator();
            InitialSolVision();
            ApplyTheme();
            InitializeLogicBuilder();
            SolDL.UpdateClassNamesEvent += UpdateClassNames;
        }

        private void DemoApp_FormClosing(object sender, FormClosingEventArgs e)
        {
            SolDL?.Close();
            SolDL?.CloseFromDLL();
            currentImage?.Dispose();
        }

        public void InitialSolVision()
        {
            if (null == System.Windows.Application.Current)
            {
                new System.Windows.Application();
            }

            SolDL = new SolVision.TaskProcess(ExecuteType.Dll);
            ElementHost.EnableModelessKeyboardInterop(SolDL);
            SolDL.Visibility = System.Windows.Visibility.Hidden;
        }

        private async void BT_LoadProject_Click(object sender, EventArgs e)
        {
            using (OpenFileDialog dlg = new OpenFileDialog())
            {
                dlg.Filter = "SolVision Project (*.tsp)|*.tsp";
                dlg.Multiselect = false;
                if (dlg.ShowDialog() == DialogResult.OK)
                {
                    await LoadProjectAsync(SolDL, dlg.FileName, isPrimary: true);
                }
            }
        }

        private void BT_LoadImg_Click(object sender, EventArgs e)
        {
            using (OpenFileDialog dlg = new OpenFileDialog())
            {
                dlg.Filter = "Image (*.png;*.jpg;*.bmp;*.tif)|*.png;*.jpg;*.bmp;*.tif";
                dlg.Multiselect = false;
                if (dlg.ShowDialog() == DialogResult.OK)
                {
                    if (!File.Exists(dlg.FileName))
                    {
                        outToLog("Selected image file does not exist.", LogStatus.Error);
                        return;
                    }

                    outToLog("Loading image...", LogStatus.Progress);

                    currentImage?.Dispose();
                    currentImage = new DetectImg
                    {
                        OriImgPath = dlg.FileName,
                        OriImg = CvInvoke.Imread(dlg.FileName, ImreadModes.ColorBgr)
                    };
                    currentImage.ObjList.Clear();

                    DisplayOriginalImage();
                    ClearDetectionVisuals();

                    outToLog($"Image loaded: {Path.GetFileName(dlg.FileName)}", LogStatus.Success);
                }
            }
        }

        private async Task LoadProjectAsync(SolVision.TaskProcess process, string filePath, bool isPrimary)
        {
            if (process == null || string.IsNullOrWhiteSpace(filePath))
            {
                return;
            }

            string fileName = Path.GetFileName(filePath);
            outToLog($"Loading project: {fileName}...", LogStatus.Progress);
            ApplyStatusToAll($"Loading project: {fileName}...", statusNeutralBackground, statusNeutralForeground);

            SetWorkflowControlsEnabled(false);
            ShowLoadingIndicator($"Loading project: {fileName}...");

            string errorMessage = null;
            bool success = false;

            try
            {
                await Task.Run(() =>
                {
                    SolVision.TaskProcess.SetLoadingInThread(true);
                    try
                    {
                        var dispatcher = System.Windows.Application.Current?.Dispatcher;
                        if (dispatcher != null)
                        {
                            dispatcher.Invoke(() => System.Windows.Application.Current.MainWindow = process);
                        }

                        process.LoadProject(filePath);
                        success = true;
                    }
                    catch (Exception ex)
                    {
                        errorMessage = ex.Message;
                    }
                    finally
                    {
                        SolVision.TaskProcess.SetLoadingInThread(false);
                    }
                });
            }
            finally
            {
                SetWorkflowControlsEnabled(true);
                HideLoadingIndicator();
            }

            if (!success)
            {
                string message = $"Project load failed: {errorMessage ?? "Unknown error"}";
                ApplyStatusToAll(message, statusFailBackground, statusFailForeground);
                outToLog(message, LogStatus.Error);
                return;
            }

            ApplyStatusToAll($"Project loaded: {fileName}", statusPassBackground, statusPassForeground);
            outToLog($"Project loaded: {fileName}", LogStatus.Success);

            if (isPrimary)
            {
                loadedProjectPath = filePath;
                TB_ProjectPath.Text = filePath;
            }

            SetLogicStatusNeutral("Awaiting detection.");
            UpdateLogicEvaluation();
        }

        private void SetWorkflowControlsEnabled(bool enabled)
        {
            BT_LoadProject.Enabled = enabled;
            BT_LoadImg.Enabled = enabled;
            BT_Detect.Enabled = enabled;
        }

        private void ShowLoadingIndicator(string message)
        {
            if (IsDisposed)
            {
                return;
            }

            if (InvokeRequired)
            {
                Invoke(new Action<string>(ShowLoadingIndicator), message);
                return;
            }

            loadingRequestCount++;
            loadingSpinner.Visible = true;
            loadingIndicatorPanel.Visible = true;
            if (toolTip != null)
            {
                toolTip.SetToolTip(loadingIndicatorPanel, message);
            }
            PositionLoadingIndicator();
            loadingIndicatorPanel.BringToFront();
            UseWaitCursor = true;
        }

        private void HideLoadingIndicator()
        {
            if (IsDisposed)
            {
                return;
            }

            if (InvokeRequired)
            {
                Invoke(new Action(HideLoadingIndicator));
                return;
            }

            loadingRequestCount = Math.Max(0, loadingRequestCount - 1);
            if (loadingRequestCount == 0)
            {
                loadingIndicatorPanel.Visible = false;
                loadingSpinner.Visible = false;
                UseWaitCursor = false;
            }
        }

        private void BT_Detect_Click(object sender, EventArgs e)
        {
            if (!EnsureReadyForDetection())
            {
                return;
            }

            outToLog("Running detection...", LogStatus.Progress);
            SetLogicStatusNeutral("Running detection...");
            ShowLoadingIndicator("Running detection...");

            BT_Detect.Enabled = false;
            Task.Run(() => DetectThreadImpl());
        }

        private bool EnsureReadyForDetection()
        {
            if (SolDL == null)
            {
                outToLog("SDK not initialized.", LogStatus.Error);
                return false;
            }

            if (string.IsNullOrWhiteSpace(loadedProjectPath))
            {
                outToLog("Please select a TSP project before running detection.", LogStatus.Warning);
                return false;
            }

            if (currentImage?.OriImg == null)
            {
                outToLog("Please upload an image before running detection.", LogStatus.Warning);
                return false;
            }

            return true;
        }

        private void DetectThreadImpl()
        {
            var targetImage = currentImage;
            if (targetImage?.OriImg == null)
            {
                BeginInvoke(new MethodInvoker(() =>
                {
                    outToLog("No image available for detection.", LogStatus.Warning);
                    BT_Detect.Enabled = true;
                    SetLogicStatusNeutral("Awaiting detection.");
                    HideLoadingIndicator();
                }));
                return;
            }

            try
            {
                Stopwatch countTime = Stopwatch.StartNew();
                List<ObjectInfo> detections;
                using (Mat matImg = targetImage.OriImg.Clone())
                {
                    SolDL.Detect(matImg, out detections);
                }
                countTime.Stop();

                if (targetImage == currentImage)
                {
                    currentImage.ObjList = detections ?? new List<ObjectInfo>();
                }

                BeginInvoke(new MethodInvoker(() =>
                {
                    if (targetImage == currentImage)
                    {
                        currentImage.HasResults = true;
                        RenderAllDetections();
                        PopulateDetectionGrid(currentImage.ObjList);
                        if (CB_Field.SelectedValue is LogicField selectedField && selectedField == LogicField.ClassName)
                        {
                            UpdateValueSuggestions(LogicField.ClassName, CB_Value.Text);
                        }
                        UpdateLogicEvaluation();
                        outToLog($"Detection finished in {countTime.ElapsedMilliseconds} ms for {Path.GetFileName(currentImage.OriImgPath)}.", LogStatus.Success);
                    }
                    BT_Detect.Enabled = true;
                    HideLoadingIndicator();
                }));
            }
            catch (Exception ex)
            {
                BeginInvoke(new MethodInvoker(() =>
                {
                    outToLog($"Detection failed: {ex.Message}", LogStatus.Error);
                    BT_Detect.Enabled = true;
                    if (currentImage != null)
                    {
                        currentImage.HasResults = false;
                    }
                    SetLogicStatusNeutral("Detection failed.");
                    HideLoadingIndicator();
                }));
            }
        }

        protected void UpdateClassNames(List<string> classNames)
        {
            classNameList = classNames;
            if (CB_Field != null && CB_Field.Visible && CB_Field.SelectedValue is LogicField field && field == LogicField.ClassName)
            {
                UpdateValueSuggestions(LogicField.ClassName, CB_Value?.Text);
            }
        }

        public List<string> GetClassNames()
        {
            if (SolDL != null)
            {
                List<string> classNames = SolDL.GetClassNames();
                classNames.RemoveAll(p => p.Equals("BackGround", StringComparison.OrdinalIgnoreCase) || p.Equals("Unknown", StringComparison.OrdinalIgnoreCase));
                return classNames;
            }

            return new List<string> { "Object" };
        }

        private void DG_Detections_CellMouseClick(object sender, DataGridViewCellMouseEventArgs e)
        {
            if (e.RowIndex < 0 || currentImage?.ObjList == null || currentImage.ObjList.Count == 0)
            {
                return;
            }

            if (e.RowIndex >= currentImage.ObjList.Count)
            {
                return;
            }

            ObjectInfo selected = currentImage.ObjList[e.RowIndex];
            RenderSingleDetection(selected);
        }

        private void RenderAllDetections()
        {
            if (currentImage?.OriImg == null)
            {
                return;
            }

            using (Mat overlay = currentImage.OriImg.Clone())
            {
                if (currentImage.ObjList != null)
                {
                    foreach (ObjectInfo obj in currentImage.ObjList)
                    {
                        RecurDrawRec(overlay, obj, new MCvScalar(0, 255, 0));
                    }
                }

                SetPictureBoxImage(PB_DetectionOverlay, overlay.ToBitmap());
            }
        }

        private void RenderSingleDetection(ObjectInfo target)
        {
            if (currentImage?.OriImg == null || target == null)
            {
                return;
            }

            using (Mat overlay = currentImage.OriImg.Clone())
            {
                RecurDrawRec(overlay, target, new MCvScalar(0, 0, 255));
                SetPictureBoxImage(PB_DetectionOverlay, overlay.ToBitmap());
            }
        }

        private void DisplayOriginalImage()
        {
            if (currentImage?.OriImg == null)
            {
                SetPictureBoxImage(PB_OriginalImage, null);
                return;
            }

            SetPictureBoxImage(PB_OriginalImage, currentImage.OriImg.ToBitmap());
        }

        private void PopulateDetectionGrid(List<ObjectInfo> detections)
        {
            DG_Detections.Rows.Clear();
            if (detections == null)
            {
                return;
            }

            for (int i = 0; i < detections.Count; i++)
            {
                ObjectInfo obj = detections[i];
                Rectangle rec = obj.DisplayRec;
                string bounds = $"{rec.X},{rec.Y},{rec.Width},{rec.Height}";
                string className = string.IsNullOrWhiteSpace(obj.name) ? "(unknown)" : obj.name;
                float score = obj.confidence != 0 ? obj.confidence : obj.classifyScore;
                DG_Detections.Rows.Add(i + 1, className, score.ToString("0.00"), bounds);
            }
        }

        private void ClearDetectionVisuals()
        {
            if (currentImage != null)
            {
                currentImage.ObjList.Clear();
                currentImage.HasResults = false;
            }
            DG_Detections.Rows.Clear();
            SetPictureBoxImage(PB_DetectionOverlay, null);
            SetLogicStatusNeutral("Awaiting detection.");
        }

        private void RecurDrawRec(Mat img, ObjectInfo obj, MCvScalar? color = null)
        {
            if (obj == null)
            {
                return;
            }

            MCvScalar drawColor = color ?? new MCvScalar(0, 255, 0);

            if (obj.name != "twoPointCrop")
            {
                if (obj.affineAngle == 0)
                {
                    CvInvoke.Rectangle(img, obj.DisplayRec, drawColor, 3);
                }
                else
                {
                    PointF p0 = new PointF(obj.DisplayRec.Left, obj.DisplayRec.Top);
                    PointF p1 = TransferPoint(p0, new PointF(obj.DisplayRec.Right, obj.DisplayRec.Top), obj.affineAngle);
                    PointF p2 = TransferPoint(p0, new PointF(obj.DisplayRec.Right, obj.DisplayRec.Bottom), obj.affineAngle);
                    PointF p3 = TransferPoint(p0, new PointF(obj.DisplayRec.Left, obj.DisplayRec.Bottom), obj.affineAngle);
                    CvInvoke.Line(img, Point.Round(p0), Point.Round(p1), drawColor, 3);
                    CvInvoke.Line(img, Point.Round(p1), Point.Round(p2), drawColor, 3);
                    CvInvoke.Line(img, Point.Round(p2), Point.Round(p3), drawColor, 3);
                    CvInvoke.Line(img, Point.Round(p3), Point.Round(p0), drawColor, 3);
                }

                CvInvoke.PutText(img, obj.name, new Point(obj.DisplayRec.X, obj.DisplayRec.Y - 15), FontFace.HersheySimplex, 1.0, new MCvScalar(0, 0, 255), 2);
            }

            if (obj.childObjs != null && obj.childObjs.Count > 0)
            {
                foreach (ObjectInfo child in obj.childObjs)
                {
                    RecurDrawRec(img, child, color);
                }
            }
        }

        private PointF RotatePoint(PointF subPoint, double angle)
        {
            double theta = -angle / 180 * Math.PI;
            PointF point = new PointF
            {
                X = subPoint.X * (float)Math.Cos(theta) + subPoint.Y * (float)Math.Sin(theta),
                Y = -subPoint.X * (float)Math.Sin(theta) + subPoint.Y * (float)Math.Cos(theta)
            };
            return point;
        }

        private PointF TransferPoint(PointF oriPoint, PointF subPoint, double angle)
        {
            PointF distanceVector = RotatePoint(new PointF(subPoint.X - oriPoint.X, subPoint.Y - oriPoint.Y), angle);
            return new PointF(oriPoint.X + distanceVector.X, oriPoint.Y + distanceVector.Y);
        }

        private void outToLog(string output, LogStatus status = LogStatus.Info)
        {
            string formatted = FormatLogMessage(output, status);
            if (string.IsNullOrEmpty(formatted))
            {
                return;
            }

            if (RTB_Info.TextLength > 0)
            {
                RTB_Info.AppendText(Environment.NewLine);
            }
            RTB_Info.AppendText(formatted);
            RTB_Info.ScrollToCaret();
        }

        private string FormatLogMessage(string rawMessage, LogStatus status)
        {
            if (string.IsNullOrWhiteSpace(rawMessage))
            {
                return string.Empty;
            }

            string text = rawMessage.Trim();
            string description = null;

            if (text.StartsWith("ConfigParameter=", StringComparison.OrdinalIgnoreCase))
            {
                string config = ExtractAfter(text, "ConfigParameter=");
                string tool = ExtractAfter(text, "DeepLearningTool=");
                description = $"Deep learning configuration loaded (Parameter: {config}, Tool: {tool}).";
            }
            else if (text.StartsWith("Add tool", StringComparison.OrdinalIgnoreCase))
            {
                string index = ExtractAfter(text, "Add tool");
                description = $"Loaded tool index {index}.";
            }
            else if (text.StartsWith("TaskProcess:", StringComparison.OrdinalIgnoreCase))
            {
                string detail = ExtractAfter(text, "TaskProcess:");
                description = $"Task process event: {detail}.";
            }
            else if (text.StartsWith("GPUIndex", StringComparison.OrdinalIgnoreCase))
            {
                string gpu = ExtractAfter(text, "GPUIndex");
                description = $"GPU index selected: {gpu}.";
            }
            else if (text.StartsWith("create_server", StringComparison.OrdinalIgnoreCase))
            {
                string statusValue = ExtractJsonValue(text, "status");
                string port = ExtractJsonValue(text, "port");
                description = $"Inference server started (port {port}, status: {statusValue}).";
            }
            else if (text.StartsWith("CheckPort", StringComparison.OrdinalIgnoreCase))
            {
                Match portMatch = Regex.Match(text, @"CheckPort\s+(?<port>\d+)", RegexOptions.IgnoreCase);
                string port = portMatch.Success ? portMatch.Groups["port"].Value : string.Empty;
                description = string.IsNullOrEmpty(port) ? "Checking inference server port." : $"Verified inference server port {port}.";
            }
            else if (text.StartsWith("[Info] Created new shared memory", StringComparison.OrdinalIgnoreCase))
            {
                string id = ExtractAfter(text, ":");
                description = $"Shared memory created ({id}).";
            }
            else if (text.StartsWith("[Info] Link shared memory result", StringComparison.OrdinalIgnoreCase))
            {
                string statusValue = ExtractJsonValue(text, "status");
                string message = ExtractJsonValue(text, "message");
                description = $"Shared memory link {statusValue}. {message}".Trim();
            }
            else if (text.StartsWith("Init infer model", StringComparison.OrdinalIgnoreCase))
            {
                string statusValue = ExtractJsonValue(text, "status");
                string message = ExtractJsonValue(text, "message");
                string modelName = Regex.Match(message ?? string.Empty, @"Model\s+'(?<name>[^']+)'", RegexOptions.IgnoreCase).Groups["name"].Value;
                if (string.IsNullOrEmpty(modelName))
                {
                    modelName = "unknown";
                }
                description = $"Model initialized ({modelName}, status: {statusValue}).";
            }
            else
            {
                Match taskMatch = Regex.Match(text, @"^-{6}task\s+(?<index>\d+)\s*:\s*(?<duration>\d+)\s*ms", RegexOptions.IgnoreCase);
                if (taskMatch.Success)
                {
                    string idx = taskMatch.Groups["index"].Value;
                    string duration = taskMatch.Groups["duration"].Value;
                    description = $"Task {idx} completed in {duration} ms.";
                }
            }

            if (description == null)
            {
                if (text.StartsWith("SolVision Version", StringComparison.OrdinalIgnoreCase))
                {
                    description = text.Replace("SolVision Version", "SDK version");
                }
                else if (text.IndexOf("Camera is disconnected", StringComparison.OrdinalIgnoreCase) >= 0)
                {
                    description = "Camera connection not detected.";
                }
                else if (text.StartsWith("???", StringComparison.OrdinalIgnoreCase))
                {
                    description = $"SDK message (untranslated): {text.Trim('?').Trim()}";
                }
                else
                {
                    description = text;
                }
            }

            if (status == LogStatus.Info && !string.IsNullOrEmpty(description))
            {
                string normalized = description.ToLowerInvariant();
                if (normalized.Contains("failed") || normalized.Contains("error"))
                {
                    status = LogStatus.Error;
                }
                else if (normalized.Contains("not detected") || normalized.Contains("disconnected") || normalized.Contains("missing"))
                {
                    status = LogStatus.Warning;
                }
                else if (normalized.Contains("success") || normalized.Contains("initialized") || normalized.Contains("completed"))
                {
                    status = LogStatus.Success;
                }
            }

            string statusToken;
            switch (status)
            {
                case LogStatus.Success:
                    statusToken = "DONE";
                    break;
                case LogStatus.Warning:
                    statusToken = "WARN";
                    break;
                case LogStatus.Error:
                    statusToken = "FAIL";
                    break;
                case LogStatus.Progress:
                    statusToken = "WORK";
                    break;
                default:
                    statusToken = "INFO";
                    break;
            }

            return $"[{DateTime.Now:HH:mm:ss}][{statusToken}] {description}";
        }

        private static string ExtractAfter(string source, string marker)
        {
            if (string.IsNullOrEmpty(source) || string.IsNullOrEmpty(marker))
            {
                return string.Empty;
            }

            int index = source.IndexOf(marker, StringComparison.OrdinalIgnoreCase);
            if (index < 0)
            {
                return string.Empty;
            }

            string segment = source.Substring(index + marker.Length).Trim();
            if (segment.StartsWith("="))
            {
                segment = segment.Substring(1).Trim();
            }
            segment = segment.TrimEnd(',');
            return segment;
        }

        private static string ExtractJsonValue(string source, string key)
        {
            if (string.IsNullOrEmpty(source) || string.IsNullOrEmpty(key))
            {
                return string.Empty;
            }

            Match match = Regex.Match(source, $"\"{Regex.Escape(key)}\"\\s*:\\s*\"?(?<value>[^\"}}]+)\"?", RegexOptions.IgnoreCase);
            if (match.Success)
            {
                string value = match.Groups["value"].Value.Trim();
                value = value.Trim('\'');
                return value;
            }

            return string.Empty;
        }

        private void SetPictureBoxImage(PictureBox pictureBox, Image image)
        {
            if (pictureBox == null)
            {
                return;
            }

            Image oldImage = pictureBox.Image;
            pictureBox.Image = image;
            oldImage?.Dispose();
        }

        private void ApplyTheme()
        {
            Font baseFont = new Font("Segoe UI", 9F);
            this.Font = baseFont;

            Color background = Color.FromArgb(246, 248, 252);
            Color surface = Color.White;
            Color border = Color.FromArgb(223, 227, 235);
            Color accentPrimary = Color.FromArgb(37, 99, 235);
            Color accentHover = Color.FromArgb(53, 110, 240);
            Color accentSecondary = Color.FromArgb(94, 102, 112);

            this.BackColor = background;

            tableLayoutPanelMain.BackColor = background;
            tableLayoutSteps.BackColor = background;
            tableLayoutImages.BackColor = background;

            StyleGroupSurface(groupStep1, surface, border);
            StyleGroupSurface(groupStep2, surface, border);
            StyleGroupSurface(groupStep4, surface, border);
            StyleGroupSurface(groupStep5, surface, border);
            StyleGroupSurface(groupStep7, surface, border);
            StyleGroupSurface(groupStep3, surface, border);
            StyleGroupSurface(groupStep6, surface, border);
            StyleGroupSurface(groupLogic, surface, border);

            if (leftTabs != null)
            {
                leftTabs.Font = new Font("Segoe UI Semibold", 9F);
                leftTabs.Appearance = TabAppearance.Normal;
                leftTabs.DrawMode = TabDrawMode.Normal;
                leftTabs.ItemSize = new Size(120, 28);
                leftTabs.SizeMode = TabSizeMode.Fixed;
                foreach (TabPage tab in leftTabs.TabPages)
                {
                    tab.BackColor = surface;
                    tab.ForeColor = Color.FromArgb(58, 66, 78);
                }
            }

            StylePrimaryButton(BT_LoadProject, accentPrimary, accentHover);
            StylePrimaryButton(BT_LoadImg, accentPrimary, accentHover);
            StylePrimaryButton(BT_Detect, Color.FromArgb(18, 163, 123), Color.FromArgb(16, 149, 113));

            TB_ProjectPath.BorderStyle = BorderStyle.FixedSingle;
            TB_ProjectPath.BackColor = Color.FromArgb(252, 253, 255);
            TB_ProjectPath.ForeColor = accentSecondary;

            RTB_Info.BorderStyle = BorderStyle.None;
            RTB_Info.BackColor = Color.FromArgb(249, 250, 253);
            RTB_Info.ForeColor = accentSecondary;
            RTB_Info.Font = new Font("Consolas", 9F);
            RTB_Info.Margin = new Padding(16);

            ConfigureDataGridView(DG_Detections, surface, border, accentPrimary, accentSecondary);

            PB_OriginalImage.BackColor = Color.FromArgb(245, 247, 252);
            PB_OriginalImage.BorderStyle = BorderStyle.FixedSingle;
            PB_DetectionOverlay.BackColor = Color.FromArgb(245, 247, 252);
            PB_DetectionOverlay.BorderStyle = BorderStyle.FixedSingle;

            tableLayoutLogic.BackColor = surface;
            panelLogicEditor.BackColor = surface;
            tableLayoutLogicButtons.BackColor = Color.Transparent;

            TV_Logic.BackColor = Color.FromArgb(249, 250, 253);
            TV_Logic.ForeColor = accentSecondary;
            TV_Logic.BorderStyle = BorderStyle.None;
            TV_Logic.Font = new Font("Segoe UI", 9F);
            TV_Logic.LineColor = Color.FromArgb(210, 216, 226);

            foreach (ComboBox combo in new[] { CB_GroupOperator, CB_Field, CB_Operator, CB_Value })
            {
                combo.FlatStyle = FlatStyle.Flat;
                combo.BackColor = Color.FromArgb(252, 253, 255);
                combo.ForeColor = accentSecondary;
                combo.Margin = new Padding(0, 4, 0, 4);
            }

            CB_Value.AutoCompleteMode = AutoCompleteMode.SuggestAppend;
            CB_Value.AutoCompleteSource = AutoCompleteSource.ListItems;
            CB_Value.DropDownStyle = ComboBoxStyle.DropDown;

            StylePrimaryButton(BT_AddRule, accentPrimary, accentHover);
            StylePrimaryButton(BT_AddGroup, accentPrimary, accentHover);
            BT_AddRule.Height = 28;
            BT_AddGroup.Height = 28;
            BT_AddRule.Margin = new Padding(2, 0, 2, 0);
            BT_AddGroup.Margin = new Padding(2, 0, 2, 0);

            StylePrimaryButton(BT_LogicHelp, accentSecondary, Color.FromArgb(76, 84, 94));
            BT_LogicHelp.BackColor = Color.FromArgb(231, 233, 238);
            BT_LogicHelp.ForeColor = Color.FromArgb(58, 66, 78);
            BT_LogicHelp.Width = 28;
            BT_LogicHelp.Height = 28;

            StyleDangerButton(BT_RemoveNode, Color.FromArgb(224, 68, 67), Color.FromArgb(205, 58, 57));
            BT_RemoveNode.Height = 28;
            BT_RemoveNode.Margin = new Padding(2, 0, 2, 0);

            StyleStatusLabel(LBL_ResultStatus);
            StyleStatusLabel(LBL_WorkflowStatus);
            SetLogicStatusNeutral("Awaiting detection.");

            this.Padding = new Padding(12);
        }

        private void BuildLogicBuilderUI()
        {
            toolTip = new ToolTip();

            leftTabs = new TabControl
            {
                Dock = DockStyle.Fill,
                Appearance = TabAppearance.Normal,
                SizeMode = TabSizeMode.Fixed,
                ItemSize = new Size(120, 28)
            };

            tabWorkflow = new TabPage("Workflow")
            {
                Padding = new Padding(8)
            };
            tabLogicBuilder = new TabPage("Logic Builder")
            {
                Padding = new Padding(10)
            };

            tableLayoutPanelMain.Controls.Remove(tableLayoutSteps);
            tableLayoutSteps.Dock = DockStyle.Fill;
            workflowLayout = new TableLayoutPanel
            {
                Dock = DockStyle.Fill,
                RowCount = 2,
                ColumnCount = 1
            };
            workflowLayout.RowStyles.Add(new RowStyle(SizeType.Percent, 100F));
            workflowLayout.RowStyles.Add(new RowStyle(SizeType.Absolute, 48F));
            workflowLayout.ColumnStyles.Add(new ColumnStyle(SizeType.Percent, 100F));

            LBL_WorkflowStatus = new Label
            {
                Dock = DockStyle.Fill,
                Text = "Awaiting project.",
                TextAlign = ContentAlignment.MiddleLeft,
                Padding = new Padding(16, 12, 16, 12),
                Margin = new Padding(0, 8, 0, 0)
            };

            workflowLayout.Controls.Add(tableLayoutSteps, 0, 0);
            workflowLayout.Controls.Add(LBL_WorkflowStatus, 0, 1);
            tabWorkflow.Controls.Add(workflowLayout);

            groupLogic = new GroupBox
            {
                Text = "Logic Rules",
                Dock = DockStyle.Fill,
                Padding = new Padding(12, 24, 12, 12)
            };

            tableLayoutLogic = new TableLayoutPanel
            {
                ColumnCount = 2,
                Dock = DockStyle.Fill,
                Margin = new Padding(0)
            };
            tableLayoutLogic.ColumnStyles.Add(new ColumnStyle(SizeType.Percent, 40F));
            tableLayoutLogic.ColumnStyles.Add(new ColumnStyle(SizeType.Percent, 60F));
            tableLayoutLogic.RowCount = 2;
            tableLayoutLogic.RowStyles.Add(new RowStyle(SizeType.Percent, 100F));
            tableLayoutLogic.RowStyles.Add(new RowStyle(SizeType.Absolute, 56F));

            TV_Logic = new TreeView
            {
                Dock = DockStyle.Fill,
                HideSelection = false
            };
            TV_Logic.AfterSelect += TV_Logic_AfterSelect;

            panelLogicEditor = new Panel
            {
                Dock = DockStyle.Fill,
                Margin = new Padding(0)
            };

            tableLayoutLogicEditor = new TableLayoutPanel
            {
                ColumnCount = 2,
                Dock = DockStyle.Fill,
                Margin = new Padding(0)
            };
            tableLayoutLogicEditor.ColumnStyles.Add(new ColumnStyle(SizeType.Percent, 38F));
            tableLayoutLogicEditor.ColumnStyles.Add(new ColumnStyle(SizeType.Percent, 62F));
            tableLayoutLogicEditor.RowCount = 6;
            tableLayoutLogicEditor.RowStyles.Add(new RowStyle(SizeType.Absolute, 32F));
            tableLayoutLogicEditor.RowStyles.Add(new RowStyle(SizeType.Absolute, 32F));
            tableLayoutLogicEditor.RowStyles.Add(new RowStyle(SizeType.Absolute, 32F));
            tableLayoutLogicEditor.RowStyles.Add(new RowStyle(SizeType.Absolute, 32F));
            tableLayoutLogicEditor.RowStyles.Add(new RowStyle(SizeType.AutoSize));
            tableLayoutLogicEditor.RowStyles.Add(new RowStyle(SizeType.Percent, 100F));

            labelLogicGroup = new Label
            {
                Text = "Group",
                Dock = DockStyle.Fill,
                TextAlign = ContentAlignment.MiddleLeft
            };

            CB_GroupOperator = new ComboBox
            {
                Dock = DockStyle.Fill,
                DropDownStyle = ComboBoxStyle.DropDownList
            };
            CB_GroupOperator.SelectedIndexChanged += CB_GroupOperator_SelectedIndexChanged;

            labelLogicField = new Label
            {
                Text = "Field",
                Dock = DockStyle.Fill,
                TextAlign = ContentAlignment.MiddleLeft
            };

            CB_Field = new ComboBox
            {
                Dock = DockStyle.Fill,
                DropDownStyle = ComboBoxStyle.DropDownList
            };
            CB_Field.SelectedIndexChanged += CB_Field_SelectedIndexChanged;

            labelLogicOperator = new Label
            {
                Text = "Operator",
                Dock = DockStyle.Fill,
                TextAlign = ContentAlignment.MiddleLeft
            };

            CB_Operator = new ComboBox
            {
                Dock = DockStyle.Fill,
                DropDownStyle = ComboBoxStyle.DropDownList
            };
            CB_Operator.SelectedIndexChanged += CB_Operator_SelectedIndexChanged;

            labelLogicValue = new Label
            {
                Text = "Value",
                Dock = DockStyle.Fill,
                TextAlign = ContentAlignment.MiddleLeft
            };

            CB_Value = new ComboBox
            {
                Dock = DockStyle.Fill,
                DropDownStyle = ComboBoxStyle.DropDown
            };
            CB_Value.SelectedIndexChanged += CB_Value_TextChanged;
            CB_Value.TextChanged += CB_Value_TextChanged;
            CB_Value.Margin = new Padding(0, 0, 0, 10);

            tableLayoutLogicButtons = new TableLayoutPanel
            {
                Dock = DockStyle.Fill,
                ColumnCount = 3,
                Margin = new Padding(0, 10, 0, 4)
            };
            tableLayoutLogicButtons.ColumnStyles.Add(new ColumnStyle(SizeType.Percent, 34F));
            tableLayoutLogicButtons.ColumnStyles.Add(new ColumnStyle(SizeType.Percent, 33F));
            tableLayoutLogicButtons.ColumnStyles.Add(new ColumnStyle(SizeType.Percent, 33F));

            BT_AddRule = new Button
            {
                Text = "Add Fail Rule",
                Dock = DockStyle.Fill
            };
            BT_AddRule.Click += BT_AddRule_Click;

            BT_AddGroup = new Button
            {
                Text = "Add Fail Group",
                Dock = DockStyle.Fill
            };
            BT_AddGroup.Click += BT_AddGroup_Click;

            BT_RemoveNode = new Button
            {
                Text = "Remove",
                Dock = DockStyle.Fill
            };
            BT_RemoveNode.Click += BT_RemoveNode_Click;

            tableLayoutLogicButtons.Controls.Add(BT_AddRule, 0, 0);
            tableLayoutLogicButtons.Controls.Add(BT_AddGroup, 1, 0);
            tableLayoutLogicButtons.Controls.Add(BT_RemoveNode, 2, 0);

            tableLayoutLogicEditor.Controls.Add(labelLogicGroup, 0, 0);
            tableLayoutLogicEditor.Controls.Add(CB_GroupOperator, 1, 0);
            tableLayoutLogicEditor.Controls.Add(labelLogicField, 0, 1);
            tableLayoutLogicEditor.Controls.Add(CB_Field, 1, 1);
            tableLayoutLogicEditor.Controls.Add(labelLogicOperator, 0, 2);
            tableLayoutLogicEditor.Controls.Add(CB_Operator, 1, 2);
            tableLayoutLogicEditor.Controls.Add(labelLogicValue, 0, 3);
            tableLayoutLogicEditor.Controls.Add(CB_Value, 1, 3);
            tableLayoutLogicEditor.Controls.Add(tableLayoutLogicButtons, 0, 4);
            tableLayoutLogicEditor.SetColumnSpan(tableLayoutLogicButtons, 2);
            Panel logicSpacer = new Panel { Dock = DockStyle.Fill };
            tableLayoutLogicEditor.Controls.Add(logicSpacer, 0, 5);
            tableLayoutLogicEditor.SetColumnSpan(logicSpacer, 2);

            panelLogicEditor.Controls.Add(tableLayoutLogicEditor);

            LBL_ResultStatus = new Label
            {
                Dock = DockStyle.Fill,
                Text = "Awaiting detection.",
                TextAlign = ContentAlignment.MiddleLeft,
                BorderStyle = BorderStyle.None,
                Margin = new Padding(3, 0, 3, 0)
            };

            tableLayoutLogic.Controls.Add(TV_Logic, 0, 0);
            tableLayoutLogic.Controls.Add(panelLogicEditor, 1, 0);
            tableLayoutLogic.Controls.Add(LBL_ResultStatus, 0, 1);
            tableLayoutLogic.SetColumnSpan(LBL_ResultStatus, 2);

            groupLogic.Controls.Add(tableLayoutLogic);

            logicHeaderPanel = new Panel
            {
                Dock = DockStyle.Fill,
                Padding = new Padding(0, 0, 0, 8)
            };

            labelLogicHeader = new Label
            {
                Text = "Define FAIL conditions. During inspection, if any rule or group below evaluates to TRUE, the inspection FAILS.",
                Dock = DockStyle.Fill,
                TextAlign = ContentAlignment.MiddleLeft
            };

            BT_LogicHelp = new Button
            {
                Text = "?",
                Width = 32,
                Height = 32,
                FlatStyle = FlatStyle.Flat,
                Margin = new Padding(12, 0, 0, 0)
            };
            BT_LogicHelp.FlatAppearance.BorderSize = 0;
            BT_LogicHelp.Click += BT_LogicHelp_Click;
            toolTip.SetToolTip(BT_LogicHelp, "Open help on how logic evaluation affects pass/fail results.");
            toolTip.SetToolTip(CB_GroupOperator, "Choose how child rules combine: ANY (fail if any match) or ALL (fail if all match).");
            toolTip.SetToolTip(CB_Field, "Select the detection property this fail rule should examine.");
            toolTip.SetToolTip(CB_Operator, "Pick how to compare the detection value.");
            toolTip.SetToolTip(CB_Value, "Enter the value that should trigger a fail when the condition is true.");

            logicHeaderPanel.Controls.Add(BT_LogicHelp);
            logicHeaderPanel.Controls.Add(labelLogicHeader);
            BT_LogicHelp.Dock = DockStyle.Right;
            labelLogicHeader.Dock = DockStyle.Fill;

            logicRootLayout = new TableLayoutPanel
            {
                Dock = DockStyle.Fill,
                RowCount = 2
            };
            logicRootLayout.RowStyles.Add(new RowStyle(SizeType.Absolute, 56F));
            logicRootLayout.RowStyles.Add(new RowStyle(SizeType.Percent, 100F));
            logicRootLayout.Controls.Add(logicHeaderPanel, 0, 0);
            logicRootLayout.Controls.Add(groupLogic, 0, 1);

            tabLogicBuilder.Controls.Add(logicRootLayout);

            leftTabs.TabPages.Add(tabWorkflow);
            leftTabs.TabPages.Add(tabLogicBuilder);

            tableLayoutPanelMain.Controls.Add(leftTabs, 0, 0);
            tableLayoutPanelMain.SetColumn(leftTabs, 0);
            tableLayoutPanelMain.SetRow(leftTabs, 0);
        }

        private void InitializeLoadingIndicator()
        {
            loadingSpinner = new ProgressBar
            {
                Style = ProgressBarStyle.Marquee,
                MarqueeAnimationSpeed = 35,
                Size = new Size(80, 8),
                Visible = false
            };

            loadingIndicatorPanel = new Panel
            {
                AutoSize = true,
                BackColor = Color.Transparent,
                Visible = false
            };

            loadingIndicatorPanel.Controls.Add(loadingSpinner);
            loadingIndicatorPanel.Anchor = AnchorStyles.Top | AnchorStyles.Right;

            Controls.Add(loadingIndicatorPanel);
            loadingIndicatorPanel.BringToFront();

            Resize += (s, e) => PositionLoadingIndicator();
            Shown += (s, e) => PositionLoadingIndicator();
        }

        private void StyleGroupSurface(Control container, Color surface, Color border)
        {
            if (container is GroupBox groupBox)
            {
                groupBox.BackColor = surface;
                groupBox.ForeColor = Color.FromArgb(60, 72, 88);
                groupBox.Font = new Font("Segoe UI Semibold", 9.5F);
                groupBox.Padding = new Padding(12, 24, 12, 12);
            }
            else
            {
                container.BackColor = surface;
            }

            if (container is TableLayoutPanel panel)
            {
                panel.CellBorderStyle = TableLayoutPanelCellBorderStyle.None;
                panel.Padding = new Padding(0);
            }

            container.Margin = new Padding(8);
            container.ForeColor = Color.FromArgb(40, 48, 56);

            if (container is Control ctrl)
            {
                ctrl.Paint += (s, e) =>
                {
                    if (s is GroupBox gb)
                    {
                        Rectangle rect = new Rectangle(0, 7, gb.Width - 1, gb.Height - 8);
                        e.Graphics.Clear(ctrl.Parent.BackColor);
                        using (Brush bodyBrush = new SolidBrush(gb.BackColor))
                        {
                            e.Graphics.FillRectangle(bodyBrush, rect);
                        }
                        using (Pen pen = new Pen(border))
                        {
                            e.Graphics.DrawRectangle(pen, rect);
                        }

                        using (Brush brush = new SolidBrush(gb.BackColor))
                        {
                            SizeF textSize = e.Graphics.MeasureString(gb.Text, gb.Font);
                            RectangleF textRect = new RectangleF(12, 0, textSize.Width + 6, textSize.Height);
                            e.Graphics.FillRectangle(brush, textRect);
                            using (Brush textBrush = new SolidBrush(gb.ForeColor))
                            {
                                e.Graphics.DrawString(gb.Text, gb.Font, textBrush, 12, 0);
                            }
                        }
                    }
                };
            }
        }

        private void StylePrimaryButton(Button button, Color accent, Color hoverAccent)
        {
            button.FlatStyle = FlatStyle.Flat;
            button.FlatAppearance.BorderSize = 0;
            button.BackColor = accent;
            button.ForeColor = Color.White;
            button.Font = new Font("Segoe UI Semibold", 9.5F);
            button.Height = 38;
            button.Margin = new Padding(6);
            button.Cursor = Cursors.Hand;

            button.MouseEnter += (s, e) => button.BackColor = hoverAccent;
            button.MouseLeave += (s, e) => button.BackColor = accent;
        }

        private void StyleDangerButton(Button button, Color accent, Color hoverAccent)
        {
            button.FlatStyle = FlatStyle.Flat;
            button.FlatAppearance.BorderSize = 0;
            button.BackColor = accent;
            button.ForeColor = Color.White;
            button.Font = new Font("Segoe UI", 9F);
            button.Cursor = Cursors.Hand;

            button.MouseEnter += (s, e) => button.BackColor = hoverAccent;
            button.MouseLeave += (s, e) => button.BackColor = accent;
        }

        private void StyleStatusLabel(Label label)
        {
            if (label == null)
            {
                return;
            }

            label.BorderStyle = BorderStyle.None;
            label.Padding = new Padding(16, 10, 16, 10);
            label.Margin = new Padding(8, 8, 8, 0);
            label.Font = new Font("Segoe UI Semibold", 9.5F);
            label.BackColor = statusNeutralBackground;
            label.ForeColor = statusNeutralForeground;
        }

        private void UpdateStatusLabel(Label label, Color backColor, Color foreColor, string text)
        {
            if (label == null)
            {
                return;
            }

            label.BackColor = backColor;
            label.ForeColor = foreColor;
            label.Text = text;
        }

        private void PositionLoadingIndicator()
        {
            if (loadingIndicatorPanel == null)
            {
                return;
            }

            int margin = 16;
            int x = ClientSize.Width - loadingIndicatorPanel.Width - margin;
            int y = margin;

            if (x < margin)
            {
                x = margin;
            }

            loadingIndicatorPanel.Location = new Point(x, y);
        }

        private void ConfigureDataGridView(DataGridView grid, Color surface, Color border, Color accent, Color textColor)
        {
            grid.BackgroundColor = surface;
            grid.GridColor = border;
            grid.BorderStyle = BorderStyle.None;
            grid.EnableHeadersVisualStyles = false;

            grid.ColumnHeadersDefaultCellStyle.BackColor = Color.FromArgb(241, 243, 248);
            grid.ColumnHeadersDefaultCellStyle.ForeColor = Color.FromArgb(58, 66, 78);
            grid.ColumnHeadersDefaultCellStyle.Font = new Font("Segoe UI Semibold", 9F);
            grid.ColumnHeadersDefaultCellStyle.Alignment = DataGridViewContentAlignment.MiddleLeft;
            grid.ColumnHeadersHeight = 34;

            grid.DefaultCellStyle.BackColor = surface;
            grid.DefaultCellStyle.SelectionBackColor = Color.FromArgb(223, 230, 253);
            grid.DefaultCellStyle.SelectionForeColor = accent;
            grid.DefaultCellStyle.ForeColor = textColor;
            grid.DefaultCellStyle.Font = new Font("Segoe UI", 9F);
            grid.RowTemplate.Height = 36;

            grid.AlternatingRowsDefaultCellStyle.BackColor = Color.FromArgb(250, 251, 253);
            grid.RowHeadersVisible = false;
            grid.ColumnHeadersBorderStyle = DataGridViewHeaderBorderStyle.None;
            grid.CellBorderStyle = DataGridViewCellBorderStyle.SingleHorizontal;
        }

        private void InitializeLogicBuilder()
        {
            logicRoot = new RuleGroupNode { Operator = LogicalOperatorType.Or };

            suppressLogicEvents = true;

            CB_GroupOperator.DisplayMember = "Display";
            CB_GroupOperator.ValueMember = "Value";
            CB_GroupOperator.DataSource = GetGroupOperatorOptions();

            CB_Field.DisplayMember = "Display";
            CB_Field.ValueMember = "Value";
            CB_Field.DataSource = GetFieldOptions();
            CB_Field.SelectedValue = LogicField.ClassName;

            UpdateOperatorOptions(LogicField.ClassName, LogicOperator.Equals);
            UpdateValueSuggestions(LogicField.ClassName);

            suppressLogicEvents = false;

            RefreshLogicTree();
        }

        private List<ComboOption<LogicalOperatorType>> GetGroupOperatorOptions()
        {
            return new List<ComboOption<LogicalOperatorType>>
            {
                new ComboOption<LogicalOperatorType>("Match ANY (OR)", LogicalOperatorType.Or),
                new ComboOption<LogicalOperatorType>("Match ALL (AND)", LogicalOperatorType.And)
            };
        }

        private List<ComboOption<LogicField>> GetFieldOptions()
        {
            return new List<ComboOption<LogicField>>
            {
                new ComboOption<LogicField>("Class Name", LogicField.ClassName),
                new ComboOption<LogicField>("Confidence", LogicField.Confidence),
                new ComboOption<LogicField>("Area (px\u00B2)", LogicField.Area),
                new ComboOption<LogicField>("Detection Count", LogicField.Count)
            };
        }

        private List<ComboOption<LogicOperator>> GetOperatorOptions(LogicField field)
        {
            if (field == LogicField.ClassName)
            {
                return new List<ComboOption<LogicOperator>>
                {
                    new ComboOption<LogicOperator>("equals", LogicOperator.Equals),
                    new ComboOption<LogicOperator>("does not equal", LogicOperator.NotEquals),
                    new ComboOption<LogicOperator>("contains", LogicOperator.Contains),
                    new ComboOption<LogicOperator>("starts with", LogicOperator.StartsWith),
                    new ComboOption<LogicOperator>("ends with", LogicOperator.EndsWith)
                };
            }

            return new List<ComboOption<LogicOperator>>
            {
                new ComboOption<LogicOperator>("=", LogicOperator.Equals),
                new ComboOption<LogicOperator>("≠", LogicOperator.NotEquals),
                new ComboOption<LogicOperator>(">", LogicOperator.GreaterThan),
                new ComboOption<LogicOperator>("≥", LogicOperator.GreaterThanOrEqual),
                new ComboOption<LogicOperator>("<", LogicOperator.LessThan),
                new ComboOption<LogicOperator>("≤", LogicOperator.LessThanOrEqual)
            };
        }

        private void RefreshLogicTree(Guid? selectId = null)
        {
            if (logicRoot == null)
            {
                logicRoot = new RuleGroupNode { Operator = LogicalOperatorType.Or };
            }

            Guid targetId = selectId ?? (TV_Logic.SelectedNode?.Tag as LogicNodeBase)?.Id ?? logicRoot.Id;

            suppressLogicEvents = true;

            TV_Logic.BeginUpdate();
            TV_Logic.Nodes.Clear();
            TreeNode rootNode = CreateTreeNode(logicRoot);
            TV_Logic.Nodes.Add(rootNode);
            rootNode.ExpandAll();
            TreeNode selectedNode = FindNodeById(rootNode, targetId) ?? rootNode;
            TV_Logic.SelectedNode = selectedNode;
            TV_Logic.EndUpdate();

            suppressLogicEvents = false;

            DisplaySelectedNode(TV_Logic.SelectedNode);
            UpdateLogicEvaluation();
        }

        private TreeNode CreateTreeNode(LogicNodeBase node)
        {
            if (node is RuleGroupNode group)
            {
                TreeNode treeNode = new TreeNode(FormatGroupText(group)) { Tag = group };
                foreach (LogicNodeBase child in group.Children)
                {
                    treeNode.Nodes.Add(CreateTreeNode(child));
                }
                return treeNode;
            }

            if (node is RuleConditionNode rule)
            {
                return new TreeNode(FormatRuleText(rule)) { Tag = rule };
            }

            return new TreeNode("(unknown node)") { Tag = node };
        }

        private TreeNode FindNodeById(TreeNode source, Guid id)
        {
            if (source?.Tag is LogicNodeBase logic && logic.Id == id)
            {
                return source;
            }

            foreach (TreeNode child in source.Nodes)
            {
            TreeNode match = FindNodeById(child, id);
            if (match != null)
            {
                return match;
            }
            }

            return null;
        }

        private void DisplaySelectedNode(TreeNode node)
        {
            bool previousSuppress = suppressLogicEvents;
            suppressLogicEvents = true;

            bool isGroup = node?.Tag is RuleGroupNode;
            bool isRule = node?.Tag is RuleConditionNode;

            SetGroupEditorVisibility(isGroup);
            SetRuleEditorVisibility(isRule);

            if (isGroup)
            {
                var group = (RuleGroupNode)node.Tag;
                CB_GroupOperator.SelectedValue = group.Operator;
            }

            if (isRule)
            {
                var rule = (RuleConditionNode)node.Tag;
                CB_Field.SelectedValue = rule.Field;
                UpdateOperatorOptions(rule.Field, rule.Operator);
                UpdateValueSuggestions(rule.Field, rule.Value);
                CB_Value.Text = rule.Value ?? string.Empty;
            }
            else
            {
                CB_Value.Text = string.Empty;
            }

            BT_RemoveNode.Enabled = node != null && node.Tag is LogicNodeBase logicNode && logicNode != logicRoot;

            suppressLogicEvents = previousSuppress;
        }

        private void SetGroupEditorVisibility(bool visible)
        {
            labelLogicGroup.Visible = visible;
            CB_GroupOperator.Visible = visible;
            CB_GroupOperator.Enabled = visible;
        }

        private void SetRuleEditorVisibility(bool visible)
        {
            labelLogicField.Visible = visible;
            CB_Field.Visible = visible;
            labelLogicOperator.Visible = visible;
            CB_Operator.Visible = visible;
            labelLogicValue.Visible = visible;
            CB_Value.Visible = visible;

            CB_Field.Enabled = visible;
            CB_Operator.Enabled = visible;
            CB_Value.Enabled = visible;
        }

        private void TV_Logic_AfterSelect(object sender, TreeViewEventArgs e)
        {
            if (suppressLogicEvents)
            {
                return;
            }

            DisplaySelectedNode(e.Node);
        }

        private void CB_GroupOperator_SelectedIndexChanged(object sender, EventArgs e)
        {
            if (suppressLogicEvents)
            {
                return;
            }

            if (TV_Logic.SelectedNode?.Tag is RuleGroupNode group && CB_GroupOperator.SelectedValue is LogicalOperatorType logicOperator)
            {
                group.Operator = logicOperator;
                RefreshLogicTree(group.Id);
            }
        }

        private void CB_Field_SelectedIndexChanged(object sender, EventArgs e)
        {
            if (suppressLogicEvents)
            {
                return;
            }

            if (TV_Logic.SelectedNode?.Tag is RuleConditionNode rule && CB_Field.SelectedValue is LogicField field)
            {
                rule.Field = field;
                rule.Operator = UpdateOperatorOptions(field, rule.Operator);
                UpdateValueSuggestions(field, rule.Value);
                RefreshLogicTree(rule.Id);
            }
        }

        private void CB_Operator_SelectedIndexChanged(object sender, EventArgs e)
        {
            if (suppressLogicEvents)
            {
                return;
            }

            if (TV_Logic.SelectedNode?.Tag is RuleConditionNode rule && CB_Operator.SelectedValue is LogicOperator op)
            {
                rule.Operator = op;
                RefreshLogicTree(rule.Id);
            }
        }

        private void CB_Value_TextChanged(object sender, EventArgs e)
        {
            if (suppressLogicEvents)
            {
                return;
            }

            if (TV_Logic.SelectedNode?.Tag is RuleConditionNode rule)
            {
                rule.Value = CB_Value.Text?.Trim() ?? string.Empty;
                RefreshLogicTree(rule.Id);
            }
        }

        private void BT_AddRule_Click(object sender, EventArgs e)
        {
            var targetGroup = GetTargetGroup();
            var newRule = new RuleConditionNode();
            targetGroup.Children.Add(newRule);
            RefreshLogicTree(newRule.Id);
        }

        private void BT_AddGroup_Click(object sender, EventArgs e)
        {
            var targetGroup = GetTargetGroup();
            var newGroup = new RuleGroupNode();
            targetGroup.Children.Add(newGroup);
            RefreshLogicTree(newGroup.Id);
        }

        private void BT_RemoveNode_Click(object sender, EventArgs e)
        {
            if (TV_Logic.SelectedNode?.Tag is LogicNodeBase node)
            {
                if (node == logicRoot)
                {
                    outToLog("Root group cannot be removed.", LogStatus.Warning);
                    return;
                }

                if (RemoveNodeFromGroup(logicRoot, node.Id))
                {
                    RefreshLogicTree(logicRoot.Id);
                }
            }
        }

        private RuleGroupNode GetTargetGroup()
        {
            if (TV_Logic.SelectedNode?.Tag is RuleGroupNode groupNode)
            {
                return groupNode;
            }

            if (TV_Logic.SelectedNode?.Tag is LogicNodeBase logicNode)
            {
                return FindParentGroup(logicRoot, logicNode.Id) ?? logicRoot;
            }

            return logicRoot ?? (logicRoot = new RuleGroupNode { Operator = LogicalOperatorType.Or });
        }

        private RuleGroupNode FindParentGroup(RuleGroupNode parent, Guid childId)
        {
            foreach (LogicNodeBase child in parent.Children)
            {
                if (child.Id == childId)
                {
                    return parent;
                }

                if (child is RuleGroupNode group)
                {
                    RuleGroupNode candidate = FindParentGroup(group, childId);
                    if (candidate != null)
                    {
                        return candidate;
                    }
                }
            }

            return null;
        }

        private bool RemoveNodeFromGroup(RuleGroupNode parent, Guid targetId)
        {
            for (int i = 0; i < parent.Children.Count; i++)
            {
                LogicNodeBase child = parent.Children[i];
                if (child.Id == targetId)
                {
                    parent.Children.RemoveAt(i);
                    return true;
                }

                if (child is RuleGroupNode group && RemoveNodeFromGroup(group, targetId))
                {
                    if (group.Children.Count == 0)
                    {
                        parent.Children.Remove(group);
                    }
                    return true;
                }
            }

            return false;
        }

        private void UpdateLogicEvaluation()
        {
            if (logicRoot == null)
            {
                return;
            }

            if (logicRoot.Children.Count == 0)
            {
                ApplyStatusToAll("Result: PASS (no rules defined)", statusPassBackground, statusPassForeground);
                return;
            }

            if (currentImage == null || !currentImage.HasResults)
            {
                SetLogicStatusNeutral("Awaiting detection.");
                return;
            }

            bool fail = EvaluateNode(logicRoot, currentImage.ObjList, out LogicNodeBase triggered);
            if (fail)
            {
                string description = triggered is RuleConditionNode rule
                    ? FormatRuleText(rule)
                    : triggered is RuleGroupNode group
                        ? FormatGroupText(group)
                        : null;

                string message = description == null ? "Result: FAIL" : $"Result: FAIL ({description})";
                ApplyStatusToAll(message, statusFailBackground, statusFailForeground);
                if (triggered != null)
                {
                    HighlightTriggeredNode(triggered.Id);
                    outToLog($"Fail triggered by: {description}", LogStatus.Warning);
                }
            }
            else
            {
                ApplyStatusToAll("Result: PASS (no fail conditions matched)", statusPassBackground, statusPassForeground);
            }
        }

        private void SetLogicStatusNeutral(string message)
        {
            ApplyStatusToAll(message, statusNeutralBackground, statusNeutralForeground);
        }

        private void HighlightTriggeredNode(Guid nodeId)
        {
            if (TV_Logic == null || TV_Logic.Nodes.Count == 0)
            {
                return;
            }

            TreeNode match = FindNodeById(TV_Logic.Nodes[0], nodeId);
            if (match != null)
            {
                suppressLogicEvents = true;
                TV_Logic.SelectedNode = match;
                TV_Logic.Focus();
                suppressLogicEvents = false;
            }
        }

        private void ApplyStatusToAll(string message, Color background, Color foreground)
        {
            UpdateStatusLabel(LBL_ResultStatus, background, foreground, message);
            UpdateStatusLabel(LBL_WorkflowStatus, background, foreground, message);
        }

        private bool EvaluateNode(LogicNodeBase node, List<ObjectInfo> detections, out LogicNodeBase triggered)
        {
            triggered = null;

            if (node is RuleConditionNode rule)
            {
                bool result = EvaluateCondition(rule, detections);
                if (result)
                {
                    triggered = rule;
                }
                return result;
            }

            if (node is RuleGroupNode group)
            {
                if (group.Operator == LogicalOperatorType.And)
                {
                    LogicNodeBase lastTrigger = null;
                    foreach (LogicNodeBase child in group.Children)
                    {
                        if (!EvaluateNode(child, detections, out LogicNodeBase childTrigger))
                        {
                            triggered = null;
                            return false;
                        }

                        if (childTrigger != null)
                        {
                            lastTrigger = childTrigger;
                        }
                    }

                    triggered = lastTrigger ?? group;
                    return group.Children.Count > 0;
                }
                else
                {
                    foreach (LogicNodeBase child in group.Children)
                    {
                        if (EvaluateNode(child, detections, out LogicNodeBase childTrigger))
                        {
                            triggered = childTrigger ?? child;
                            return true;
                        }
                    }

                    triggered = null;
                    return false;
                }
            }

            return false;
        }

        private bool EvaluateCondition(RuleConditionNode rule, List<ObjectInfo> detections)
        {
            string inputValue = rule.Value?.Trim() ?? string.Empty;

            switch (rule.Field)
            {
                case LogicField.ClassName:
                    IEnumerable<string> names = detections.Select(obj => obj.name ?? string.Empty);
                    return EvaluateStringCondition(names, rule.Operator, inputValue);
                case LogicField.Confidence:
                    IEnumerable<double> confidences = detections.Select(GetConfidenceValue);
                    return EvaluateNumericCondition(confidences, rule.Operator, inputValue);
                case LogicField.Area:
                    IEnumerable<double> areas = detections.Select(obj =>
                    {
                        Rectangle rect = obj.DisplayRec;
                        return (double)(Math.Abs(rect.Width) * Math.Abs(rect.Height));
                    });
                    return EvaluateNumericCondition(areas, rule.Operator, inputValue);
                case LogicField.Count:
                    if (!TryParseDouble(inputValue, out double threshold))
                    {
                        return false;
                    }
                    return CompareNumeric(detections.Count, threshold, rule.Operator);
                default:
                    return false;
            }
        }

        private bool EvaluateStringCondition(IEnumerable<string> values, LogicOperator op, string target)
        {
            if (string.IsNullOrWhiteSpace(target) && op != LogicOperator.NotEquals)
            {
                return false;
            }

            List<string> list = values.ToList();

            switch (op)
            {
                case LogicOperator.Equals:
                    return list.Any(v => string.Equals(v, target, StringComparison.OrdinalIgnoreCase));
                case LogicOperator.NotEquals:
                    if (list.Count == 0)
                    {
                        return true;
                    }
                    return list.All(v => !string.Equals(v, target, StringComparison.OrdinalIgnoreCase));
                case LogicOperator.Contains:
                    return list.Any(v => v.IndexOf(target, StringComparison.OrdinalIgnoreCase) >= 0);
                case LogicOperator.StartsWith:
                    return list.Any(v => v.StartsWith(target, StringComparison.OrdinalIgnoreCase));
                case LogicOperator.EndsWith:
                    return list.Any(v => v.EndsWith(target, StringComparison.OrdinalIgnoreCase));
                default:
                    return false;
            }
        }

        private void BT_LogicHelp_Click(object sender, EventArgs e)
        {
            const string helpMessage =
                "Logic Builder checks detection results after each run.\n\n" +
                "• Groups combine child rules using ALL (AND) or ANY (OR).\n" +
                "• Each rule compares a field (class, confidence, area, count) with the value you provide.\n" +
                "• If ANY rule evaluates to TRUE, the inspection is marked as FAIL.\n" +
                "• With no rules, the inspection defaults to PASS.\n\n" +
                "Tip: Build layered groups to model complex acceptance criteria.";

            MessageBox.Show(helpMessage, "Logic Builder Help", MessageBoxButtons.OK, MessageBoxIcon.Information);
        }

        private bool EvaluateNumericCondition(IEnumerable<double> values, LogicOperator op, string target)
        {
            if (!TryParseDouble(target, out double threshold))
            {
                return false;
            }

            List<double> list = values.Where(v => !double.IsNaN(v) && !double.IsInfinity(v)).ToList();
            if (list.Count == 0)
            {
                return false;
            }

            switch (op)
            {
                case LogicOperator.Equals:
                    return list.Any(v => AlmostEqual(v, threshold));
                case LogicOperator.NotEquals:
                    return list.All(v => !AlmostEqual(v, threshold));
                case LogicOperator.GreaterThan:
                    return list.Any(v => v > threshold);
                case LogicOperator.GreaterThanOrEqual:
                    return list.Any(v => v > threshold || AlmostEqual(v, threshold));
                case LogicOperator.LessThan:
                    return list.Any(v => v < threshold);
                case LogicOperator.LessThanOrEqual:
                    return list.Any(v => v < threshold || AlmostEqual(v, threshold));
                default:
                    return false;
            }
        }

        private bool CompareNumeric(double left, double right, LogicOperator op)
        {
            switch (op)
            {
                case LogicOperator.Equals:
                    return AlmostEqual(left, right);
                case LogicOperator.NotEquals:
                    return !AlmostEqual(left, right);
                case LogicOperator.GreaterThan:
                    return left > right;
                case LogicOperator.GreaterThanOrEqual:
                    return left > right || AlmostEqual(left, right);
                case LogicOperator.LessThan:
                    return left < right;
                case LogicOperator.LessThanOrEqual:
                    return left < right || AlmostEqual(left, right);
                default:
                    return false;
            }
        }

        private static bool AlmostEqual(double left, double right, double tolerance = 1e-3)
        {
            return Math.Abs(left - right) <= tolerance;
        }

        private bool TryParseDouble(string input, out double value)
        {
            if (double.TryParse(input, NumberStyles.Float | NumberStyles.AllowThousands, CultureInfo.InvariantCulture, out value))
            {
                return true;
            }

            return double.TryParse(input, NumberStyles.Float | NumberStyles.AllowThousands, CultureInfo.CurrentCulture, out value);
        }

        private static double GetConfidenceValue(ObjectInfo obj)
        {
            double result = obj.confidence;
            if (Math.Abs(result) < double.Epsilon)
            {
                result = obj.classifyScore;
            }
            return result;
        }

        private string FormatGroupText(RuleGroupNode group)
        {
            string descriptor = group.Operator == LogicalOperatorType.And ? "ALL" : "ANY";
            return $"Fail when {descriptor} child rules are TRUE";
        }

        private string FormatRuleText(RuleConditionNode rule)
        {
            string fieldLabel = GetFieldLabel(rule.Field);
            string operatorLabel = GetOperatorLabel(rule.Operator);
            string value = string.IsNullOrWhiteSpace(rule.Value) ? "(value)" : rule.Value;
            return $"Fail if {fieldLabel} {operatorLabel} {value}";
        }

        private string GetFieldLabel(LogicField field)
        {
            switch (field)
            {
                case LogicField.ClassName:
                    return "Class";
                case LogicField.Confidence:
                    return "Confidence";
                case LogicField.Area:
                    return "Area";
                case LogicField.Count:
                    return "Count";
                default:
                    return field.ToString();
            }
        }

        private string GetOperatorLabel(LogicOperator op)
        {
            switch (op)
            {
                case LogicOperator.Equals:
                    return "is";
                case LogicOperator.NotEquals:
                    return "is not";
                case LogicOperator.GreaterThan:
                    return ">";
                case LogicOperator.GreaterThanOrEqual:
                    return ">=";
                case LogicOperator.LessThan:
                    return "<";
                case LogicOperator.LessThanOrEqual:
                    return "<=";
                case LogicOperator.Contains:
                    return "contains";
                case LogicOperator.StartsWith:
                    return "starts with";
                case LogicOperator.EndsWith:
                    return "ends with";
                default:
                    return op.ToString();
            }
        }

        private LogicOperator UpdateOperatorOptions(LogicField field, LogicOperator? preferred = null)
        {
            List<ComboOption<LogicOperator>> options = GetOperatorOptions(field);
            List<ComboOption<LogicOperator>> dataSource = options.Select(option => new ComboOption<LogicOperator>(option.Display, option.Value)).ToList();

            bool previousSuppress = suppressLogicEvents;
            suppressLogicEvents = true;

            CB_Operator.DisplayMember = "Display";
            CB_Operator.ValueMember = "Value";
            CB_Operator.DataSource = dataSource;

            LogicOperator selected = preferred.HasValue && dataSource.Any(o => o.Value.Equals(preferred.Value))
                ? preferred.Value
                : dataSource.First().Value;
            CB_Operator.SelectedValue = selected;

            suppressLogicEvents = previousSuppress;
            return selected;
        }

        private void UpdateValueSuggestions(LogicField field, string preferredValue = null)
        {
            bool previousSuppress = suppressLogicEvents;
            suppressLogicEvents = true;

            List<string> suggestions = new List<string>();

            if (field == LogicField.ClassName)
            {
                if (classNameList != null)
                {
                    suggestions.AddRange(classNameList);
                }

                if (currentImage?.ObjList != null)
                {
                    suggestions.AddRange(currentImage.ObjList.Select(obj => obj.name ?? string.Empty));
                }
            }
            else if (field == LogicField.Count)
            {
                if (currentImage?.ObjList != null)
                {
                    suggestions.Add(currentImage.ObjList.Count.ToString(CultureInfo.InvariantCulture));
                }
            }
            else if (field == LogicField.Confidence && currentImage?.ObjList != null)
            {
                suggestions.AddRange(currentImage.ObjList
                    .Select(GetConfidenceValue)
                    .Where(v => !double.IsNaN(v))
                    .Select(v => v.ToString("0.###", CultureInfo.InvariantCulture)));
            }
            else if (field == LogicField.Area && currentImage?.ObjList != null)
            {
                suggestions.AddRange(currentImage.ObjList
                    .Select(obj => (double)(Math.Abs(obj.DisplayRec.Width) * Math.Abs(obj.DisplayRec.Height)))
                    .Where(v => v > 0)
                    .Select(v => v.ToString("0.##", CultureInfo.InvariantCulture)));
            }

            suggestions = suggestions
                .Where(item => !string.IsNullOrWhiteSpace(item))
                .Distinct(StringComparer.OrdinalIgnoreCase)
                .Take(25)
                .ToList();

            CB_Value.BeginUpdate();
            CB_Value.Items.Clear();
            AutoCompleteStringCollection autoSource = new AutoCompleteStringCollection();
            foreach (string suggestion in suggestions)
            {
                CB_Value.Items.Add(suggestion);
                autoSource.Add(suggestion);
            }
            CB_Value.AutoCompleteCustomSource = autoSource;

            if (!string.IsNullOrWhiteSpace(preferredValue))
            {
                CB_Value.Text = preferredValue;
            }
            else if (suggestions.Count > 0)
            {
                CB_Value.Text = suggestions[0];
            }
            else
            {
                CB_Value.Text = string.Empty;
            }

            CB_Value.EndUpdate();

            suppressLogicEvents = previousSuppress;
        }

        private enum LogicField
        {
            ClassName,
            Confidence,
            Area,
            Count
        }

        private enum LogicOperator
        {
            Equals,
            NotEquals,
            GreaterThan,
            GreaterThanOrEqual,
            LessThan,
            LessThanOrEqual,
            Contains,
            StartsWith,
            EndsWith
        }

        private enum LogicalOperatorType
        {
            Or,
            And
        }

        private abstract class LogicNodeBase
        {
            public Guid Id { get; } = Guid.NewGuid();
        }

        private class RuleGroupNode : LogicNodeBase
        {
            public LogicalOperatorType Operator { get; set; } = LogicalOperatorType.Or;
            public List<LogicNodeBase> Children { get; } = new List<LogicNodeBase>();
        }

        private class RuleConditionNode : LogicNodeBase
        {
            public LogicField Field { get; set; } = LogicField.ClassName;
            public LogicOperator Operator { get; set; } = LogicOperator.Equals;
            public string Value { get; set; } = string.Empty;
        }

        private class ComboOption<T>
        {
            public ComboOption(string display, T value)
            {
                Display = display;
                Value = value;
            }

            public string Display { get; }
            public T Value { get; }

            public override string ToString() => Display;
        }
    }

    internal class DetectImg : IDisposable
    {
        internal Mat OriImg;
        internal string OriImgPath;
        internal List<ObjectInfo> ObjList = new List<ObjectInfo>();
        internal bool HasResults;

        public void Dispose()
        {
            OriImg?.Dispose();
            OriImg = null;
            ObjList?.Clear();
            HasResults = false;
        }
    }
}
